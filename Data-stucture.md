###Hashing
---
In general, in all searching techniques, search time is dependent on the number of items. Sequential search, binary search and all the search trees are totally dependent on number of items and many key comparisons are involved.

**Hashing is a technique where search time is independent of the number of items or elements. In this technique a hash function is used to generate an address from a key. The hash function takes a key as input and returns the hash value of that key which is used as an address index in the array.**

**Techniques for making hash function.**

- **Truncation Method**: In this method we take only a part of the key as address.
- **Midsquare Method**: In this method the key is squared and some digits from the middle of this square are taken as address.
- **Folding Method**: In this technique the key is divided into different part where the length of each part is same as that of the required address, except possibly the last part.
- **Division Method(Modulo-Division)**: In Modulo-Division method the key is mod by the table size and the remainder is taken as the address of the hash table.


**Collision resolution**:

- Open Addressing (Closed Hashing)
  * Linear Probing 
  * Quadratic Probing
  * Double Hashing
- Separate Chaining (Open Hashing)

**Linear probing**:

In this method if address given by hash function is already occupied, then **the key will be inserted in the next empty position in hash table**. 
For a given hash value, the indices generated by linear probing are as follows:

**H + 1 , H + 2 , H + 3 , H + 4 , ... , H + k**

 **The performance of linear probing is also more sensitive to input distribution when compared to double hashing**, where the step size is determined by another hash function applied to the value instead of a fixed step size as in linear probing.

**Quadratic probing**:
An example sequence using quadratic probing is:

**H + 1^2 , H + 2^2 , H + 3^2 , H + 4^2 , ... , H + k^2**

**Quadratic probing** can be a more efficient algorithm in a closed hash table, since it **better avoids the clustering problem** that can occur with linear probing, although it is not immune. It also provides good memory caching because it preserves some locality of reference; however, **linear probing has greater locality and, thus, better cache performance.**

**Double hashing:**

Given two randomly, uniformly, and independently selected hash functions h_1 and h_2, the ith location in the bucket sequence for value k in a hash table T is: **h(i,k)=(h_1(k) + i * h_2(k)) mod |T|** Generally, h_1 and h_2 are selected from a set of universal hash functions.

http://www.careerride.com/Data-Structure-Interview-Questions.aspx


###AVL tree or height balanced binary search tree.
---

An AVL tree is **binary search tree (BST)** where the **difference in the height** of left and right subtrees of any node can be **at most one**.

**Rotation**:
After insertion or deletion operation the balance factor of the nodes in AVL tree can be changed and the tree may not be balanced. We can balance this tree by performing tree rotations.

- Right Rotation 
- Left Rotation


###DFS vs BFS
---

That heavily depends on the structure of the search tree and the number and location of solutions (aka searched-for items). 

If you know a solution is not far from the root of the tree, a breadth first search (BFS) might be better. **If the tree is very deep and solutions are rare, depth first search (DFS) might take an extremely long time, but BFS could be faster**. **If the tree is very wide, a BFS might need too much memory, so it might be completely impractical.** If solutions are frequent but located deep in the tree, BFS could be impractical. If the search tree is very deep you will need to restrict the search depth for depth first search (DFS), anyway (for example with iterative deepening).

It should be mentioned that there's a less-known variant that combines the space efficiency of DFS, but (cummulatively) the level-order visitation of BFS, is the **iterative deepening depth-first search**. This algorithm revisits some nodes, but it only contributes a constant factor of asymptotic difference.


http://stackoverflow.com/questions/3332947/when-is-it-practical-to-use-dfs-vs-bfs

Depth-first search (DFS) is an algorithm (or technique) for traversing a graph.

Following are the problems that use DFS as a bulding block.

1) For an unweighted graph, DFS traversal of the graph produces the minimum spanning tree and all pair shortest path tree.

2) Detecting cycle in a graph 
A graph has cycle if and only if we see a back edge during DFS. So we can run DFS for the graph and check for back edges. (See this for details)

3) Path Finding
We can specialize the DFS algorithm to find a path between two given vertices u and z.
i) Call DFS(G, u) with u as the start vertex.
ii) Use a stack S to keep track of the path between the start vertex and the current vertex.
iii) As soon as destination vertex z is encountered, return the path as the
contents of the stack

See this for details.

4) Topological Sorting
See this for details.

5) To test if a graph is bipartite
We can augment either BFS or DFS when we first discover a new vertex, color it opposited its parents, and for each other edge, check it doesn’t link two vertices of the same color. The first vertex in any connected component can be red or black! See this for details.

6) Finding Strongly Connected Components of a graph A directed graph is called strongly connected if there is a path from each vertex in the graph to every other vertex. (See this for DFS based algo for finding Strongly Connected Components)

7) Solving puzzles with only one solution, such as mazes. (DFS can be adapted to find all solutions to a maze by only including nodes on the current path in the visited set.)

http://www.geeksforgeeks.org/applications-of-depth-first-search/

1) Shortest Path and Minimum Spanning Tree for unweighted graph In unweighted graph, the shortest path is the path with least number of edges. With Breadth First, we always reach a vertex from given source using minimum number of edges. Also, in case of unweighted graphs, any spanning tree is Minimum Spanning Tree and we can use either Depth or Breadth first traversal for finding a spanning tree.

2) Peer to Peer Networks. In Peer to Peer Networks like BitTorrent, Breadth First Search is used to find all neighbor nodes.

3) Crawlers in Search Engines: Crawlers build index using Bread First. The idea is to start from source page and follow all links from source and keep doing same. Depth First Traversal can also be used for crawlers, but the advantage with Breadth First Traversal is, depth or levels of built tree can be limited.

4) Social Networking Websites: In social networks, we can find people within a given distance ‘k’ from a person using Breadth First Search till ‘k’ levels.

5) GPS Navigation systems: Breadth First Search is used to find all neighboring locations.

6) Broadcasting in Network: In networks, a broadcasted packet follows Breadth First Search to reach all nodes.

7) In Garbage Collection: Breadth First Search is used in copying garbage collection using Cheney’s algorithm. Refer this and for details. Breadth First Search is preferred over Depth First Search because of better locality of reference:

8) Cycle detection in undirected graph: In undirected graphs, either Breadth First Search or Depth First Search can be used to detect cycle. In directed graph, only depth first search can be used.

9) Ford–Fulkerson algorithm In Ford-Fulkerson algorithm, we can either use Breadth First or Depth First Traversal to find the maximum flow. Breadth First Traversal is preferred as it reduces worst case time complexity to O(VE2).

10) To test if a graph is Bipartite We can either use Breadth First or Depth First Traversal.

11) Path Finding We can either use Breadth First or Depth First Traversal to find if there is a path between two vertices.

12) Finding all nodes within one connected component: We can either use Breadth First or Depth First Traversal to find all nodes reachable from a given node.

Many algorithms like Prim’s Minimum Spanning Tree and Dijkstra’s Single Source Shortest Path use structure similar to Breadth First Search.

There can be many more applications as Breadth First Search is one of the core algorithm for Graphs.




